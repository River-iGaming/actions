name: Merge Branch With Conflict Resolution
description: Merges a source branch into a target branch and auto-resolves version file conflicts.

inputs:
  source-branch:
    description: 'Branch to merge from'
    required: true
  target-branch:
    description: 'Branch to merge into'
    required: true
  version-files:
    description: 'List of version files'
    required: false
    default: |
      package.json
  include-commit:
    description: 'Whether to commit and push the merged branch'
    required: false
    default: 'true'
  skip-checkout:
    description: 'Whether to checkout the target branch'
    required: false
    default: 'false'
  github-token:
    description: 'GitHub token with write permissions'
    required: true

outputs:
  manual-merge:
    description: 'true if manual merge is required due to unresolvable conflicts'
    value: ${{ steps.merge.outputs.manual-merge }}
  auto-resolved:
    description: 'true if conflicts were auto-resolved'
    value: ${{ steps.merge.outputs.auto-resolved }}

runs:
  using: 'composite'
  steps:
    - name: Checkout full history
      if: inputs.skip-checkout == 'false'
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ inputs.github-token }}
        ref: ${{ inputs.source-branch }}

    - name: Merge source into target with auto-resolve
      id: merge
      shell: bash
      run: |
        git fetch --all
        git config user.email "deploy-bot@riverigaming.com"
        git config user.name "rig-autobot"

        SOURCE_BRANCH="${{ inputs.source-branch }}"
        TARGET_BRANCH="${{ inputs.target-branch }}"
        MANUAL_MERGE=false
        AUTO_RESOLVED=false

        git checkout "$TARGET_BRANCH"

        echo "::notice::Merging branch: $SOURCE_BRANCH into: $TARGET_BRANCH"

        if git merge --no-commit --no-ff --no-edit "$SOURCE_BRANCH"; then
          if [[ -z "$(git status --porcelain)" ]]; then
            echo "::notice::Nothing to commit for branch: $TARGET_BRANCH"
          fi
        else
          CONFLICTS=$(git diff --name-only --diff-filter=U)
          echo "::warning::Conflicts: $CONFLICTS"

          for file in $CONFLICTS; do
            IS_VERSION_FILE=false
            
            readarray -t VERSION_FILES <<< "${{ inputs.version-files }}"
            VERSION_FILES=($(printf "%s\n" "${VERSION_FILES[@]}" | sed '/^\s*$/d'))

            for vfile in "${VERSION_FILE_LIST[@]}"; do
              if [[ "$file" == "$vfile" ]]; then
                IS_VERSION_FILE=true
                break
              fi
            done

            if [[ "$IS_VERSION_FILE" == true ]]; then
              echo "::notice::Auto-resolving $file version conflicts."
              git checkout --ours "$file"
              git add "$file"
              AUTO_RESOLVED=true
            else
              echo "::error::❌ Conflict in $file cannot be auto-resolved. Aborting merge."
              git merge --abort
              MANUAL_MERGE=true
              break
            fi
          done
        fi

        echo "manual-merge=$MANUAL_MERGE" >> "$GITHUB_OUTPUT"
        echo "auto-resolved=$AUTO_RESOLVED" >> "$GITHUB_OUTPUT"

    - name: Commit and push merged changes
      if: inputs.include-commit == 'true' && steps.merge.outputs.manual-merge == 'false'
      shell: bash
      run: |
        AUTO_RESOLVED = "${{ steps.merge.outputs.auto-resolved }}"
        if [[ -n "$(git status --porcelain)" ]]; then
          
          if [[ "$AUTO_RESOLVED" == true ]]; then
            echo "::notice::⚠️ Conflicts auto-resolved, commit and pushing ${{ inputs.target-branch }}"
            git commit -m "chore(*): auto-resolve version conflicts"
          else
            echo "::notice::✅ Commit and pushing ${{ inputs.target-branch }}"
            git commit --no-edit
          fi
          git push origin "${{ inputs.target-branch }}"
        fi
